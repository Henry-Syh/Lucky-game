<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ–ï¸ äº”è·¯è²¡ç¥ (æœ€çµ‚ç‰ˆ)</title>
    <style>
        :root {
            --card-w: 58px;
            --card-h: 88px;
            --slot-border: rgba(255, 215, 0, 0.6);
            --bg-dark: #1a472a;
            --bg-light: #2c6e43;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--bg-dark);
            margin: 0;
            padding: 0;
            overflow: hidden;
            color: white;
            touch-action: none;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ—ï¼Œè§£æ±ºç•™ç™½å•é¡Œ */
        }

        /* 1. æ¨™é¡Œå€ (å›ºå®šé«˜åº¦) */
        header {
            height: 50px;
            background: rgba(0,0,0,0.3);
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
            z-index: 200;
        }
        h1 { margin: 0; font-size: 1.1rem; color: #f1c40f; }
        p { margin: 2px 0 0; font-size: 0.75rem; color: #ccc; }

        /* 2. æ’æ§½å€ (å›ºå®šé«˜åº¦ï¼Œç·Šæ¥æ¨™é¡Œ) */
        .slots-wrapper {
            height: 110px;
            background: var(--bg-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
            padding-top: 10px;
        }

        .slot {
            width: var(--card-w);
            height: var(--card-h);
            border: 2px dashed var(--slot-border);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: rgba(0,0,0,0.2);
            transition: border-color 0.3s;
        }

        .slot-label {
            position: absolute;
            top: -20px;
            font-size: 0.8rem;
            color: #f1c40f;
            font-weight: bold;
        }

        /* 3. æ¡Œé¢å€ (è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“) */
        .table-zone {
            flex-grow: 1; /* é—œéµï¼šå¡«æ»¿å‰©ä¸‹é«˜åº¦ */
            width: 100%;
            background-image: radial-gradient(var(--bg-light), var(--bg-dark));
            border-top: 3px solid #f1c40f; /* é»ƒç·š */
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .guide-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.2);
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: none;
        }

        /* å¡ç‰Œæ¨£å¼ */
        .card {
            width: var(--card-w);
            height: var(--card-h);
            position: absolute;
            border-radius: 6px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            cursor: grab;
            z-index: 100;
            
            /* ç‰ŒèƒŒæ¨£å¼ (è±æ ¼ç´‹) */
            background-color: #b71c1c;
            background-image: 
                linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.1) 75%, transparent 75%, transparent),
                linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.1) 75%, transparent 75%, transparent);
            background-size: 10px 10px;
            border: 2px solid #fff;
            
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0;
            color: transparent;
            touch-action: none;
        }

        /* é»æ“Šç¿»ç‰Œæ™‚çš„å‹•ç•« */
        .card.flipping {
            animation: flipEffect 0.6s forwards;
        }

        @keyframes flipEffect {
            0% { transform: rotateY(0deg) scale(1); }
            50% { transform: rotateY(90deg) scale(1.1); background-color: #eee; }
            100% { transform: rotateY(0deg) scale(1); background-color: white; }
        }

        /* ç¿»é–‹å¾Œçš„æ¨£å¼ */
        .card.revealed {
            background: white;
            font-size: 1.5rem;
            border: 2px solid #333;
        }
        .card.revealed.red { color: #c0392b; }
        .card.revealed.black { color: #2c3e50; }

        .suit-small { font-size: 0.9rem; position: absolute; top: 2px; left: 4px; }
        .val-large { font-size: 2rem; font-weight: bold; }

        /* æŒ‰ä½æ‹–æ›³æ™‚ */
        .card.dragging {
            box-shadow: 0 15px 30px rgba(0,0,0,0.6);
            z-index: 1000 !important;
            transform: scale(1.15) !important;
        }
        
        /* é–å®šç‹€æ…‹ (ç­‰å¾…ç¿»ç‰Œ) */
        .card.locked {
            cursor: pointer; /* æç¤ºå¯ä»¥é» */
        }
        /* å·²ç¿»é–‹ */
        .card.done {
            cursor: default;
        }

        /* æç¤ºç¿»ç‰Œçš„ç‰¹æ•ˆ */
        .card.locked:hover {
            filter: brightness(1.2);
            border-color: #f1c40f;
        }

        /* æ§åˆ¶æŒ‰éˆ•å€ */
        .controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 300; /* ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
            pointer-events: none; /* è®“é»æ“Šç©¿é€ç©ºç™½è™•ï¼Œåªè®“æŒ‰éˆ•å¯é» */
        }

        .btn {
            pointer-events: auto; /* æ¢å¾©æŒ‰éˆ•å¯é» */
            padding: 12px 35px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: all 0.2s;
        }
        
        .btn-confirm { 
            background: linear-gradient(to bottom, #f1c40f, #f39c12); 
            color: #8e44ad; 
            border: 2px solid #fff;
            opacity: 0.6;
        }
        .btn-confirm.ready { 
            opacity: 1; 
            animation: pulse 1.5s infinite; 
        }
        .btn-reset { 
            background: #7f8c8d; 
            color: white; 
            border: 2px solid #bdc3c7;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(241, 196, 15, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 20px rgba(241, 196, 15, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(241, 196, 15, 0); }
        }

        /* çµæœé®ç½© */
        #result-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .final-msg { color: #f1c40f; font-size: 1.5rem; margin-bottom: 5px; }
        .final-amount { font-size: 4rem; color: #fff; font-weight: bold; margin: 10px 0; text-shadow: 0 0 30px #e74c3c; }
        .win-btn { padding: 15px 50px; font-size: 1.3rem; background: #e74c3c; color: white; border: none; border-radius: 50px; margin-top: 20px; }

        /* ç‹€æ…‹æç¤ºå­— */
        #status-bar {
            position: absolute;
            bottom: 85px;
            width: 100%;
            text-align: center;
            color: #f1c40f;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

    </style>
</head>
<body>

    <header>
        <h1>ğŸ–ï¸ äº”è·¯è²¡ç¥</h1>
        <p>10, J, Q, K = 0 | A = 1</p>
    </header>

    <div class="slots-wrapper">
        <div class="slot" id="slot-0"><div class="slot-label">è¬</div></div>
        <div class="slot" id="slot-1"><div class="slot-label">åƒ</div></div>
        <div class="slot" id="slot-2"><div class="slot-label">ç™¾</div></div>
        <div class="slot" id="slot-3"><div class="slot-label">å</div></div>
        <div class="slot" id="slot-4"><div class="slot-label">å€‹</div></div>
    </div>

    <div class="table-zone" id="table-bg">
        <div class="guide-text">æ´—ç‰Œå€<br><span style="font-size:0.8rem; font-weight:normal;">(æ‰‹æŒ‡æ»‘å‹•æ¡Œé¢å¯æ’¥ç‰Œ)</span></div>
    </div>

    <div id="status-bar">ğŸ‘‡ è«‹é»æ“Šä¸Šæ–¹å¡ç‰Œç¿»é–‹ ğŸ‘‡</div>

    <div class="controls">
        <button class="btn btn-reset" onclick="initGame()">é‡æ´—</button>
        <button class="btn btn-confirm" id="confirm-btn" onclick="startRevealPhase()" disabled>è²·å®šé›¢æ‰‹</button>
    </div>

    <div id="result-overlay">
        <div class="final-msg">ğŸ§§ æ­å–œç²å¾—ç´…åŒ… ğŸ§§</div>
        <div class="final-amount" id="final-score">$0</div>
        <button class="btn win-btn" onclick="initGame()">å†ä¾†ä¸€æŠŠ</button>
    </div>

    <a href="lobby.html" style="position: absolute; top: 15px; left: 15px; color: rgba(255,255,255,0.5); text-decoration: none; z-index: 300; font-size: 0.9rem;">&lt; å›å¤§å»³</a>

    <script>
        // --- éŠæˆ²è¨­å®š ---
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        
        let cards = [];
        let slotState = [null, null, null, null, null]; 
        let isRevealPhase = false;
        let revealedCount = 0;

        // æ‹–æ›³ç›¸é—œè®Šæ•¸
        let activeCard = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let startPos = { x: 0, y: 0 }; // è¨˜éŒ„èµ·å§‹ä½ç½®ï¼Œç”¨æ–¼åˆ¤æ–·æ˜¯å¦ç‚ºé»æ“Š

        // åˆå§‹åŒ–
        window.onload = initGame;

        function initGame() {
            // é‡ç½®æ‰€æœ‰ç‹€æ…‹
            document.body.querySelectorAll('.card').forEach(c => c.remove());
            cards = [];
            slotState = [null, null, null, null, null];
            isRevealPhase = false;
            revealedCount = 0;

            document.getElementById('result-overlay').style.display = 'none';
            document.getElementById('status-bar').style.opacity = '0';
            
            const btn = document.getElementById('confirm-btn');
            btn.innerText = "è«‹é¸æ»¿äº”å¼µ";
            btn.disabled = true;
            btn.classList.remove('ready');

            // ç”¢ç”Ÿ 52 å¼µç‰Œ
            let deckData = createDeckData();
            const tableZone = document.querySelector('.table-zone');
            const tableRect = tableZone.getBoundingClientRect();

            deckData.forEach((data, i) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.id = `card-${i}`;
                
                // æ•¸æ“š
                card.dataset.suit = data.suit;
                card.dataset.rank = data.rank;
                card.dataset.value = data.value;
                card.dataset.slotIndex = "-1"; // -1 = åœ¨æ¡Œé¢

                // éš¨æ©Ÿåˆ†ä½ˆåœ¨æ¡Œé¢å€ (table-zone)
                // å¿…é ˆè¨ˆç®—ç›¸å° body çš„åº§æ¨™
                const margin = 20;
                const minX = margin;
                const maxX = window.innerWidth - 60 - margin;
                const minY = tableRect.top + margin;
                const maxY = window.innerHeight - 90 - margin;

                const rLeft = minX + Math.random() * (maxX - minX);
                const rTop = minY + Math.random() * (maxY - minY);
                const rRot = Math.random() * 90 - 45;

                card.style.left = `${rLeft}px`;
                card.style.top = `${rTop}px`;
                card.style.transform = `rotate(${rRot}deg)`;

                // ç¶å®šäº‹ä»¶
                bindCardEvents(card);

                document.body.appendChild(card);
                cards.push(card);
            });

            // ç¶å®šæ¡Œå¸ƒæ“ç‰Œäº‹ä»¶
            bindTableEvents();
        }

        function createDeckData() {
            let d = [];
            for (let s of suits) {
                for (let r of ranks) {
                    let val = 0;
                    if (r === 'A') val = 1;
                    else if (['10', 'J', 'Q', 'K'].includes(r)) val = 0;
                    else val = parseInt(r);
                    d.push({ suit: s, rank: r, value: val });
                }
            }
            // æ´—ç‰Œ
            for (let i = d.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [d[i], d[j]] = [d[j], d[i]];
            }
            return d;
        }

        // --- äº’å‹•é‚è¼¯ 1: å¡ç‰Œæ‹–æ›³ (Drag) & ç¿»ç‰Œé»æ“Š ---
        function bindCardEvents(card) {
            // è§¸æ§
            card.addEventListener('touchstart', onDragStart, {passive: false});
            card.addEventListener('touchmove', onDragMove, {passive: false});
            card.addEventListener('touchend', onDragEnd);
            // æ»‘é¼ 
            card.addEventListener('mousedown', onDragStart);
        }

        function onDragStart(e) {
            if (isRevealPhase) {
                // å¦‚æœæ˜¯ç¿»ç‰Œéšæ®µï¼Œé»æ“Šå¡ç‰Œè§¸ç™¼ç¿»ç‰Œé‚è¼¯ï¼Œä¸æ‹–æ›³
                handleRevealClick(this);
                return;
            }

            e.preventDefault(); // é˜²æ­¢æ»¾å‹•
            
            // å¦‚æœå·²ç¶“åœ¨æ ¼å­è£¡ï¼Œå…ˆæš«æ™‚è¦–ç‚ºç§»å‡ºï¼Œæ–¹ä¾¿é‡æ’
            const currentSlot = parseInt(this.dataset.slotIndex);
            if (currentSlot !== -1) {
                slotState[currentSlot] = null;
                this.dataset.slotIndex = "-1";
                updateButtonState();
            }

            activeCard = this;
            isDragging = true;
            activeCard.classList.add('dragging');

            const touch = e.touches ? e.touches[0] : e;
            const rect = activeCard.getBoundingClientRect();
            
            // è¨ˆç®—é»æ“Šé»èˆ‡å¡ç‰‡å·¦ä¸Šè§’çš„åç§»
            dragOffset.x = touch.clientX - rect.left;
            dragOffset.y = touch.clientY - rect.top;

            // è¨˜éŒ„èµ·å§‹é»ï¼Œå¦‚æœç§»å‹•å¾ˆå°ï¼Œè¦–ç‚ºèª¤è§¸
            startPos = { x: touch.clientX, y: touch.clientY };
        }

        function onDragMove(e) {
            if (!isDragging || !activeCard) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - dragOffset.x;
            const y = touch.clientY - dragOffset.y;

            activeCard.style.left = `${x}px`;
            activeCard.style.top = `${y}px`;
            activeCard.style.transform = `rotate(0deg) scale(1.15)`; // æ‹–æ›³æ™‚æ“ºæ­£ä¸¦æ”¾å¤§

            // --- é¡å¤–åŠŸèƒ½ï¼šæ‹–æ›³æ™‚ç¢°æ’å…¶ä»–ç‰Œ (Collision Scatter) ---
            // é€™æ˜¯ç‚ºäº†å¢åŠ æ‰‹æ„Ÿï¼Œç•¶ä½ æ‹–è‘—ä¸€å¼µç‰Œç¶“éå…¶ä»–ç‰Œï¼Œå…¶ä»–ç‰Œæœƒè®“è·¯
            scatterNearbyCards(x + 30, y + 45, activeCard);
        }

        function onDragEnd(e) {
            if (!isDragging || !activeCard) return;
            
            isDragging = false;
            activeCard.classList.remove('dragging');

            // æª¢æŸ¥æ˜¯å¦æ”¾å…¥æ ¼å­
            checkDrop(activeCard);
            
            activeCard = null;
        }

        function checkDrop(card) {
            const cardRect = card.getBoundingClientRect();
            const cardCenterX = cardRect.left + cardRect.width / 2;
            const cardCenterY = cardRect.top + cardRect.height / 2;

            let dropped = false;

            // æª¢æŸ¥ 5 å€‹æ ¼å­
            for (let i = 0; i < 5; i++) {
                const slot = document.getElementById(`slot-${i}`);
                const slotRect = slot.getBoundingClientRect();

                // ç°¡å–®ç¢°æ’åˆ¤å®š
                if (cardCenterX > slotRect.left && cardCenterX < slotRect.right &&
                    cardCenterY > slotRect.top && cardCenterY < slotRect.bottom) {
                    
                    if (slotState[i] === null) {
                        snapToSlot(card, slotRect, i);
                        dropped = true;
                    } else {
                        // æ ¼å­æœ‰ç‰Œï¼Œå½ˆå›æ¡Œé¢ (æˆ–è€…ä½ å¯ä»¥å¯«äº¤æ›é‚è¼¯)
                        // é€™è£¡é¸æ“‡ç°¡å–®å½ˆå›
                    }
                    break;
                }
            }

            if (!dropped) {
                // å¦‚æœæ²’é€²æ ¼å­ï¼Œå½ˆå›æ¡Œé¢éš¨æ©Ÿä½ç½®
                returnToTable(card);
            }
        }

        function snapToSlot(card, slotRect, index) {
            // è¨ˆç®—å¸é™„ä½ç½® (ç½®ä¸­)
            // å› ç‚º card æ˜¯ absolute by bodyï¼Œç›´æ¥ç”¨ slotRect
            const newLeft = slotRect.left + (slotRect.width - parseFloat(getComputedStyle(card).width)) / 2;
            const newTop = slotRect.top + (slotRect.height - parseFloat(getComputedStyle(card).height)) / 2;

            card.style.transition = 'all 0.2s ease-out';
            card.style.left = `${newLeft}px`;
            card.style.top = `${newTop}px`;
            card.style.transform = 'rotate(0deg)';

            slotState[index] = card;
            card.dataset.slotIndex = index;

            // å‹•ç•«çµæŸå¾Œç§»é™¤ transition ä»¥å…å½±éŸ¿æ‹–æ›³
            setTimeout(() => { card.style.transition = ''; }, 200);

            updateButtonState();
        }

        function returnToTable(card) {
            const tableZone = document.querySelector('.table-zone');
            const tableRect = tableZone.getBoundingClientRect();
            
            const minX = 20;
            const maxX = window.innerWidth - 80;
            const minY = tableRect.top + 20;
            const maxY = window.innerHeight - 100;

            const rLeft = minX + Math.random() * (maxX - minX);
            const rTop = minY + Math.random() * (maxY - minY);
            const rRot = Math.random() * 60 - 30;

            card.style.transition = 'all 0.4s ease-out';
            card.style.left = `${rLeft}px`;
            card.style.top = `${rTop}px`;
            card.style.transform = `rotate(${rRot}deg)`;
            
            card.dataset.slotIndex = "-1";

            setTimeout(() => { card.style.transition = ''; }, 400);
        }

        // --- äº’å‹•é‚è¼¯ 2: æ¡Œé¢æ“ç‰Œ (Washing) ---
        function bindTableEvents() {
            const table = document.getElementById('table-bg');
            
            // ç›£è½æ¡Œå¸ƒä¸Šçš„è§¸æ§ç§»å‹•
            table.addEventListener('touchmove', (e) => {
                // å¦‚æœæ­£åœ¨æ‹–æ›³å¡ç‰‡ï¼Œå°±ä¸è§¸ç™¼æ´—ç‰Œï¼Œé¿å…è¡çª
                if (isDragging) return;
                
                // é˜»æ­¢é»˜èªæ»¾å‹•
                // e.preventDefault(); 
                
                const touch = e.touches[0];
                scatterNearbyCards(touch.clientX, touch.clientY, null);
            }, {passive: false});

             table.addEventListener('mousemove', (e) => {
                if (isDragging) return;
                if (e.buttons > 0) { // åªæœ‰æŒ‰ä¸‹æ»‘é¼ æ™‚æ‰æ’¥ç‰Œ
                    scatterNearbyCards(e.clientX, e.clientY, null);
                }
            });
        }

        // æ’¥é–‹å¡ç‰‡çš„ç‰©ç†é‚è¼¯
        function scatterNearbyCards(x, y, ignoreCard) {
            const radius = 90; // å½±éŸ¿ç¯„åœ
            const force = 15; // æ¨åŠ›

            cards.forEach(card => {
                if (card === ignoreCard) return; // ä¸æ¨è‡ªå·±
                if (card.dataset.slotIndex !== "-1") return; // ä¸æ¨æ ¼å­è£¡çš„ç‰Œ

                const rect = card.getBoundingClientRect();
                const cardCx = rect.left + rect.width/2;
                const cardCy = rect.top + rect.height/2;

                const dx = cardCx - x;
                const dy = cardCy - y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < radius) {
                    // è¨ˆç®—æ¨é–‹æ–¹å‘
                    const angle = Math.atan2(dy, dx);
                    const pushX = Math.cos(angle) * force;
                    const pushY = Math.sin(angle) * force;

                    let newLeft = parseFloat(card.style.left) + pushX;
                    let newTop = parseFloat(card.style.top) + pushY;

                    // é‚Šç•Œæª¢æŸ¥ (ä¸è®“ç‰Œè·‘å‡ºç•«é¢)
                    const tableRect = document.querySelector('.table-zone').getBoundingClientRect();
                    newLeft = Math.max(10, Math.min(window.innerWidth - 70, newLeft));
                    newTop = Math.max(tableRect.top, Math.min(window.innerHeight - 100, newTop));

                    card.style.left = `${newLeft}px`;
                    card.style.top = `${newTop}px`;
                    
                    // éš¨æ©Ÿå¾®è½‰
                    let currentRot = parseFloat(card.style.transform.replace(/[^0-9\-.]/g, '')) || 0;
                    card.style.transform = `rotate(${currentRot + (Math.random()*6-3)}deg)`;
                }
            });
        }

        function updateButtonState() {
            const isFull = !slotState.includes(null);
            const btn = document.getElementById('confirm-btn');
            
            if (isFull) {
                btn.disabled = false;
                btn.innerText = "è²·å®šé›¢æ‰‹";
                btn.classList.add('ready');
            } else {
                btn.disabled = true;
                btn.innerText = "è«‹é¸æ»¿äº”å¼µ";
                btn.classList.remove('ready');
            }
        }

        // --- éšæ®µåˆ‡æ›: æº–å‚™ç¿»ç‰Œ ---
        function startRevealPhase() {
            if (slotState.includes(null)) return;

            isRevealPhase = true;
            
            // UI æ›´æ–°
            const btn = document.getElementById('confirm-btn');
            btn.innerText = "ç¿»ç‰Œä¸­...";
            btn.classList.remove('ready');
            btn.disabled = true;

            document.getElementById('status-bar').style.opacity = '1';

            // é–å®šæ ¼å­è£¡çš„ç‰Œï¼Œè®Šæ›´æ¨£å¼æç¤ºå¯é»æ“Š
            slotState.forEach(card => {
                card.classList.add('locked');
            });

            // ç‚ºäº†é¿å…æ“‹ä½ï¼ŒæŠŠæ¡Œé¢å…¶ä»–çš„ç‰Œè®Šæš—æˆ–å¾€ä¸‹ç§» (é€™è£¡é¸æ“‡è®ŠåŠé€æ˜)
            cards.forEach(c => {
                if (c.dataset.slotIndex === "-1") {
                    c.style.opacity = '0.3';
                    c.style.pointerEvents = 'none'; // æ¡Œé¢ç‰Œä¸èƒ½å†å‹•
                }
            });
        }

        // --- äº’å‹•é‚è¼¯ 3: æ‰‹å‹•é»æ“Šç¿»ç‰Œ ---
        function handleRevealClick(card) {
            // å¿…é ˆæ˜¯ç¿»ç‰Œéšæ®µ
            if (!isRevealPhase) return;
            // å¿…é ˆæ˜¯é‚„æ²’ç¿»é–‹çš„ç‰Œ
            if (card.classList.contains('revealed')) return;
            // å¿…é ˆæ˜¯æ ¼å­è£¡çš„ç‰Œ
            if (card.dataset.slotIndex === "-1") return;

            // åŸ·è¡Œç¿»ç‰Œ
            revealOneCard(card);
        }

        function revealOneCard(card) {
            // ç§»é™¤é–å®šï¼Œæ¨™è¨˜ç‚ºå·²ç¿»
            card.classList.remove('locked');
            card.classList.add('done');
            card.classList.add('flipping'); // è§¸ç™¼ CSS å‹•ç•«

            // 0.3ç§’å¾Œ (å‹•ç•«ä¸€åŠ) æ”¹è®Šå…§å®¹
            setTimeout(() => {
                card.classList.add('revealed');
                const isRed = (card.dataset.suit === 'â™¥' || card.dataset.suit === 'â™¦');
                card.classList.add(isRed ? 'red' : 'black');
                
                card.innerHTML = `
                    <div class="suit-small">${card.dataset.suit}</div>
                    <div class="val-large">${card.dataset.rank}</div>
                `;
            }, 300);

            revealedCount++;

            // æª¢æŸ¥æ˜¯å¦å…¨éƒ¨ç¿»å®Œ
            if (revealedCount === 5) {
                setTimeout(calculateAndShowResult, 1000);
            }
        }

        function calculateAndShowResult() {
            let totalAmountStr = "";
            slotState.forEach(card => {
                totalAmountStr += card.dataset.value;
            });
            
            const finalAmount = parseInt(totalAmountStr);

            document.getElementById('result-overlay').style.display = 'flex';
            const scoreEl = document.getElementById('final-score');
            
            // æ•¸å­—è·³å‹•ç‰¹æ•ˆ
            let current = 0;
            const step = Math.max(1, Math.floor(finalAmount / 30));
            const timer = setInterval(() => {
                current += step;
                if (current >= finalAmount) {
                    current = finalAmount;
                    clearInterval(timer);
                }
                scoreEl.innerText = `$${current.toLocaleString()}`;
            }, 30);
        }

        // å°‡æ‹–æ›³èˆ‡æ»‘é¼ äº‹ä»¶æ›è¼‰åˆ° documentï¼Œä»¥é˜²æ‹–å¤ªå¿«å‡ºç•Œ
        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);

    </script>
</body>
</html>
