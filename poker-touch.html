<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ–ï¸ äº”è·¯è²¡ç¥ (åˆºæ¿€ç‰ˆ)</title>
    <style>
        :root {
            --card-w: 58px;
            --card-h: 88px;
            --slot-border: rgba(255, 215, 0, 0.6);
            --bg-dark: #1a472a;
            --bg-light: #2c6e43;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--bg-dark);
            margin: 0;
            padding: 0;
            overflow: hidden;
            color: white;
            touch-action: none;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
        }

        header {
            height: 50px;
            background: rgba(0,0,0,0.3);
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
            z-index: 200;
        }
        h1 { margin: 0; font-size: 1.1rem; color: #f1c40f; }
        p { margin: 2px 0 0; font-size: 0.75rem; color: #ccc; }

        .slots-wrapper {
            height: 110px;
            background: var(--bg-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
            padding-top: 10px;
        }

        .slot {
            width: var(--card-w);
            height: var(--card-h);
            border: 2px dashed var(--slot-border);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: rgba(0,0,0,0.2);
            transition: border-color 0.3s;
        }

        .slot-label {
            position: absolute;
            top: -20px;
            font-size: 0.8rem;
            color: #f1c40f;
            font-weight: bold;
        }

        .table-zone {
            flex-grow: 1;
            width: 100%;
            background-image: radial-gradient(var(--bg-light), var(--bg-dark));
            border-top: 3px solid #f1c40f;
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .guide-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.2);
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: none;
        }

        /* å¡ç‰ŒåŸºç¤æ¨£å¼ */
        .card {
            width: var(--card-w);
            height: var(--card-h);
            position: absolute;
            border-radius: 6px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            cursor: grab;
            z-index: 100;
            
            background-color: #b71c1c;
            background-image: 
                linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.1) 75%, transparent 75%, transparent),
                linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.1) 75%, transparent 75%, transparent);
            background-size: 10px 10px;
            border: 2px solid #fff;
            
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0;
            color: transparent;
            touch-action: none;
            transition: transform 0.1s; 
        }

        /* æ­£å¸¸ç¿»ç‰Œå‹•ç•« */
        .card.flipping {
            animation: flipEffect 0.6s forwards;
            pointer-events: none;
        }

        @keyframes flipEffect {
            0% { transform: rotateY(0deg) scale(1); }
            50% { transform: rotateY(90deg) scale(1.1); background-color: #eee; }
            100% { transform: rotateY(0deg) scale(1); background-color: white; }
        }

        /* === è¬ä½ç‰¹æ•ˆå‹•ç•« === */
        
        /* 1. ç·Šå¼µéœ‡å‹• */
        @keyframes shakeHard {
            0% { transform: translate(1px, 1px) rotate(0deg) scale(1.5); }
            10% { transform: translate(-1px, -2px) rotate(-1deg) scale(1.5); }
            20% { transform: translate(-3px, 0px) rotate(1deg) scale(1.5); }
            30% { transform: translate(3px, 2px) rotate(0deg) scale(1.5); }
            40% { transform: translate(1px, -1px) rotate(1deg) scale(1.5); }
            50% { transform: translate(-1px, 2px) rotate(-1deg) scale(1.5); }
            60% { transform: translate(-3px, 1px) rotate(0deg) scale(1.5); }
            70% { transform: translate(3px, 1px) rotate(-1deg) scale(1.5); }
            80% { transform: translate(-1px, -1px) rotate(1deg) scale(1.5); }
            90% { transform: translate(1px, 2px) rotate(0deg) scale(1.5); }
            100% { transform: translate(1px, -2px) rotate(-1deg) scale(1.5); }
        }

        /* 2. è¬ä½æº–å‚™ç‹€æ…‹ */
        .card.special-prepare {
            z-index: 2000 !important;
            transition: all 0.5s ease;
            transform: scale(1.5) !important; /* æ”¾å¤§ */
            box-shadow: 0 0 30px rgba(241, 196, 15, 0.8), 0 0 60px rgba(241, 196, 15, 0.4); /* é‡‘å…‰ */
            border-color: #f1c40f;
        }

        /* 3. è¬ä½éœ‡å‹•ç‹€æ…‹ */
        .card.special-shake {
            animation: shakeHard 0.1s infinite; /* ç„¡é™éœ‡å‹• */
        }

        /* 4. è¬ä½ç¿»é–‹å¾Œ */
        .card.special-revealed {
            background: #fffbe6; /* æ·¡é‡‘è‰²èƒŒæ™¯ */
            border: 3px solid #f1c40f; /* é‡‘æ¡† */
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.6);
            transform: scale(1.2); /* ä¿æŒç¨å¾®å¤§ä¸€é» */
            z-index: 1500;
        }

        /* é®ç½©å±¤ (ç•¶è¬ä½ç‰¹æ•ˆæ™‚è®Šæš—) */
        #dim-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1900;
            display: none;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* é€šç”¨ç¿»é–‹æ¨£å¼ */
        .card.revealed {
            background: white;
            font-size: 1.5rem;
            border: 2px solid #333;
        }
        .card.revealed.red { color: #c0392b; }
        .card.revealed.black { color: #2c3e50; }

        .suit-small { font-size: 0.9rem; position: absolute; top: 2px; left: 4px; }
        .val-large { font-size: 2rem; font-weight: bold; }

        .card.dragging {
            box-shadow: 0 15px 30px rgba(0,0,0,0.6);
            z-index: 1000 !important;
            transform: scale(1.15) !important;
            transition: none;
        }
        
        .card.locked { cursor: pointer; }
        .card.locked:hover { filter: brightness(1.2); border-color: #f1c40f; }
        .card.done { cursor: default; }

        .controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 300;
            pointer-events: none;
        }

        .btn {
            pointer-events: auto;
            padding: 12px 35px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: all 0.2s;
        }
        
        .btn-confirm { 
            background: linear-gradient(to bottom, #f1c40f, #f39c12); 
            color: #8e44ad; 
            border: 2px solid #fff;
            opacity: 0.6;
        }
        .btn-confirm.ready { opacity: 1; animation: pulse 1.5s infinite; }
        .btn-reset { 
            background: #7f8c8d; 
            color: white; 
            border: 2px solid #bdc3c7;
        }
        .btn-reset:active { transform: translateY(2px); }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(241, 196, 15, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 20px rgba(241, 196, 15, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(241, 196, 15, 0); }
        }

        #result-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .final-msg { color: #f1c40f; font-size: 1.5rem; margin-bottom: 5px; }
        .final-amount { font-size: 4rem; color: #fff; font-weight: bold; margin: 10px 0; text-shadow: 0 0 30px #e74c3c; }
        .win-btn { padding: 15px 50px; font-size: 1.3rem; background: #e74c3c; color: white; border: none; border-radius: 50px; margin-top: 20px; }

        #status-bar {
            position: absolute;
            bottom: 85px;
            width: 100%;
            text-align: center;
            color: #f1c40f;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

    </style>
</head>
<body>

    <div id="dim-overlay"></div> <header>
        <h1>ğŸ–ï¸ äº”è·¯è²¡ç¥ (åˆºæ¿€ç‰ˆ)</h1>
        <p>10, J, Q, K = 0 | A = 1</p>
    </header>

    <div class="slots-wrapper">
        <div class="slot" id="slot-0"><div class="slot-label">è¬</div></div>
        <div class="slot" id="slot-1"><div class="slot-label">åƒ</div></div>
        <div class="slot" id="slot-2"><div class="slot-label">ç™¾</div></div>
        <div class="slot" id="slot-3"><div class="slot-label">å</div></div>
        <div class="slot" id="slot-4"><div class="slot-label">å€‹</div></div>
    </div>

    <div class="table-zone" id="table-bg">
        <div class="guide-text">æ´—ç‰Œå€<br><span style="font-size:0.8rem; font-weight:normal;">(æ‰‹æŒ‡æ»‘å‹•æ¡Œé¢å¯æ’¥ç‰Œ)</span></div>
    </div>

    <div id="status-bar">ğŸ‘‡ è«‹é»æ“Šä¸Šæ–¹å¡ç‰Œç¿»é–‹ ğŸ‘‡</div>

    <div class="controls">
        <button class="btn btn-reset" onclick="shufflePoolOnly()">æ´—ç‰Œ</button>
        <button class="btn btn-confirm" id="confirm-btn" onclick="startRevealPhase()" disabled>ä¸‹å¥½é›¢æ‰‹</button>
    </div>

    <div id="result-overlay">
        <div class="final-msg">ğŸ§§ æ­å–œç²å¾—ç´…åŒ… ğŸ§§</div>
        <div class="final-amount" id="final-score">$0</div>
        <button class="btn win-btn" onclick="initGame()">å†ä¾†ä¸€æŠŠ</button>
    </div>

    <a href="lobby.html" style="position: absolute; top: 15px; left: 15px; color: rgba(255,255,255,0.5); text-decoration: none; z-index: 300; font-size: 0.9rem;">&lt; å›å¤§å»³</a>

    <script>
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        
        let cards = [];
        let slotState = [null, null, null, null, null]; 
        let isRevealPhase = false;
        let revealedCount = 0;

        let activeCard = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        window.onload = initGame;

        function initGame() {
            document.body.querySelectorAll('.card').forEach(c => c.remove());
            cards = [];
            slotState = [null, null, null, null, null];
            isRevealPhase = false;
            revealedCount = 0;

            document.getElementById('result-overlay').style.display = 'none';
            document.getElementById('status-bar').style.opacity = '0';
            document.getElementById('dim-overlay').style.display = 'none';
            document.getElementById('dim-overlay').style.opacity = '0';
            
            const btn = document.getElementById('confirm-btn');
            btn.innerText = "è«‹é¸æ»¿äº”å¼µ";
            btn.disabled = true;
            btn.classList.remove('ready');

            let deckData = createDeckData();
            const tableZone = document.querySelector('.table-zone');
            const tableRect = tableZone.getBoundingClientRect();

            deckData.forEach((data, i) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.id = `card-${i}`;
                
                card.dataset.suit = data.suit;
                card.dataset.rank = data.rank;
                card.dataset.value = data.value;
                card.dataset.slotIndex = "-1"; 

                const margin = 20;
                const minX = margin;
                const maxX = window.innerWidth - 60 - margin;
                const minY = tableRect.top + margin;
                const maxY = window.innerHeight - 90 - margin;

                const rLeft = minX + Math.random() * (maxX - minX);
                const rTop = minY + Math.random() * (maxY - minY);
                const rRot = Math.random() * 90 - 45;

                card.style.left = `${rLeft}px`;
                card.style.top = `${rTop}px`;
                card.style.transform = `rotate(${rRot}deg)`;

                bindCardEvents(card);
                document.body.appendChild(card);
                cards.push(card);
            });

            bindTableEvents();
        }

        function createDeckData() {
            let d = [];
            for (let s of suits) {
                for (let r of ranks) {
                    let val = 0;
                    if (r === 'A') val = 1;
                    else if (['10', 'J', 'Q', 'K'].includes(r)) val = 0;
                    else val = parseInt(r);
                    d.push({ suit: s, rank: r, value: val });
                }
            }
            for (let i = d.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [d[i], d[j]] = [d[j], d[i]];
            }
            return d;
        }

        function shufflePoolOnly() {
            if (isRevealPhase) return;

            const tableZone = document.querySelector('.table-zone');
            const tableRect = tableZone.getBoundingClientRect();
            const margin = 20;
            const minX = margin;
            const maxX = window.innerWidth - 60 - margin;
            const minY = tableRect.top + margin;
            const maxY = window.innerHeight - 90 - margin;

            cards.forEach(card => {
                if (card.dataset.slotIndex === "-1") {
                    const rLeft = minX + Math.random() * (maxX - minX);
                    const rTop = minY + Math.random() * (maxY - minY);
                    const rRot = Math.random() * 120 - 60;

                    card.style.transition = 'all 0.5s ease-in-out';
                    card.style.left = `${rLeft}px`;
                    card.style.top = `${rTop}px`;
                    card.style.transform = `rotate(${rRot}deg)`;

                    setTimeout(() => { card.style.transition = ''; }, 500);
                }
            });
        }

        function bindCardEvents(card) {
            card.addEventListener('touchstart', onDragStart, {passive: false});
            card.addEventListener('touchmove', onDragMove, {passive: false});
            card.addEventListener('touchend', onDragEnd);
            card.addEventListener('mousedown', onDragStart);
        }

        function onDragStart(e) {
            if (isRevealPhase) {
                handleRevealClick(this);
                return;
            }

            e.preventDefault();
            
            const currentSlot = parseInt(this.dataset.slotIndex);
            if (currentSlot !== -1) {
                slotState[currentSlot] = null;
                this.dataset.slotIndex = "-1";
                updateButtonState();
            }

            activeCard = this;
            isDragging = true;
            activeCard.classList.add('dragging');

            const touch = e.touches ? e.touches[0] : e;
            const rect = activeCard.getBoundingClientRect();
            
            dragOffset.x = touch.clientX - rect.left;
            dragOffset.y = touch.clientY - rect.top;
        }

        function onDragMove(e) {
            if (!isDragging || !activeCard) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - dragOffset.x;
            const y = touch.clientY - dragOffset.y;

            activeCard.style.left = `${x}px`;
            activeCard.style.top = `${y}px`;
            activeCard.style.transform = `rotate(0deg) scale(1.15)`;

            scatterNearbyCards(x + 30, y + 45, activeCard);
        }

        function onDragEnd(e) {
            if (!isDragging || !activeCard) return;
            isDragging = false;
            activeCard.classList.remove('dragging');
            checkDrop(activeCard);
            activeCard = null;
        }

        function checkDrop(card) {
            const cardRect = card.getBoundingClientRect();
            const cardCenterX = cardRect.left + cardRect.width / 2;
            const cardCenterY = cardRect.top + cardRect.height / 2;

            let dropped = false;

            for (let i = 0; i < 5; i++) {
                const slot = document.getElementById(`slot-${i}`);
                const slotRect = slot.getBoundingClientRect();

                if (cardCenterX > slotRect.left && cardCenterX < slotRect.right &&
                    cardCenterY > slotRect.top && cardCenterY < slotRect.bottom) {
                    
                    if (slotState[i] === null) {
                        snapToSlot(card, slotRect, i);
                        dropped = true;
                    } 
                    break;
                }
            }

            if (!dropped) {
                returnToTable(card);
            }
        }

        function snapToSlot(card, slotRect, index) {
            const newLeft = slotRect.left + (slotRect.width - parseFloat(getComputedStyle(card).width)) / 2;
            const newTop = slotRect.top + (slotRect.height - parseFloat(getComputedStyle(card).height)) / 2;

            card.style.transition = 'all 0.2s ease-out';
            card.style.left = `${newLeft}px`;
            card.style.top = `${newTop}px`;
            card.style.transform = 'rotate(0deg)';

            slotState[index] = card;
            card.dataset.slotIndex = index;

            setTimeout(() => { card.style.transition = ''; }, 200);
            updateButtonState();
        }

        function returnToTable(card) {
            const tableZone = document.querySelector('.table-zone');
            const tableRect = tableZone.getBoundingClientRect();
            
            const minX = 20;
            const maxX = window.innerWidth - 80;
            const minY = tableRect.top + 20;
            const maxY = window.innerHeight - 100;

            const rLeft = minX + Math.random() * (maxX - minX);
            const rTop = minY + Math.random() * (maxY - minY);
            const rRot = Math.random() * 60 - 30;

            card.style.transition = 'all 0.4s ease-out';
            card.style.left = `${rLeft}px`;
            card.style.top = `${rTop}px`;
            card.style.transform = `rotate(${rRot}deg)`;
            
            card.dataset.slotIndex = "-1";

            setTimeout(() => { card.style.transition = ''; }, 400);
        }

        function bindTableEvents() {
            const table = document.getElementById('table-bg');
            table.addEventListener('touchmove', (e) => {
                if (isDragging) return;
                const touch = e.touches[0];
                scatterNearbyCards(touch.clientX, touch.clientY, null);
            }, {passive: false});

             table.addEventListener('mousemove', (e) => {
                if (isDragging) return;
                if (e.buttons > 0) {
                    scatterNearbyCards(e.clientX, e.clientY, null);
                }
            });
        }

        function scatterNearbyCards(x, y, ignoreCard) {
            const radius = 90;
            const force = 15;

            cards.forEach(card => {
                if (card === ignoreCard) return;
                if (card.dataset.slotIndex !== "-1") return;

                const rect = card.getBoundingClientRect();
                const cardCx = rect.left + rect.width/2;
                const cardCy = rect.top + rect.height/2;

                const dx = cardCx - x;
                const dy = cardCy - y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < radius) {
                    const angle = Math.atan2(dy, dx);
                    const pushX = Math.cos(angle) * force;
                    const pushY = Math.sin(angle) * force;

                    let newLeft = parseFloat(card.style.left) + pushX;
                    let newTop = parseFloat(card.style.top) + pushY;

                    const tableRect = document.querySelector('.table-zone').getBoundingClientRect();
                    newLeft = Math.max(10, Math.min(window.innerWidth - 70, newLeft));
                    newTop = Math.max(tableRect.top, Math.min(window.innerHeight - 100, newTop));

                    card.style.left = `${newLeft}px`;
                    card.style.top = `${newTop}px`;
                    
                    let currentRot = parseFloat(card.style.transform.replace(/[^0-9\-.]/g, '')) || 0;
                    card.style.transform = `rotate(${currentRot + (Math.random()*6-3)}deg)`;
                }
            });
        }

        function updateButtonState() {
            const isFull = !slotState.includes(null);
            const btn = document.getElementById('confirm-btn');
            
            if (isFull) {
                btn.disabled = false;
                btn.innerText = "ä¸‹å¥½é›¢æ‰‹";
                btn.classList.add('ready');
            } else {
                btn.disabled = true;
                btn.innerText = "è«‹é¸æ»¿äº”å¼µ";
                btn.classList.remove('ready');
            }
        }

        function startRevealPhase() {
            if (slotState.includes(null)) return;

            isRevealPhase = true;
            
            const btn = document.getElementById('confirm-btn');
            btn.innerText = "ç¿»ç‰Œä¸­...";
            btn.classList.remove('ready');
            btn.disabled = true;

            document.getElementById('status-bar').style.opacity = '1';

            slotState.forEach(card => {
                card.classList.add('locked');
            });

            cards.forEach(c => {
                if (c.dataset.slotIndex === "-1") {
                    c.style.opacity = '0.3';
                    c.style.pointerEvents = 'none';
                }
            });
        }

        function handleRevealClick(card) {
            if (!isRevealPhase) return;
            if (card.dataset.slotIndex === "-1") return;
            if (card.classList.contains('revealed') || card.classList.contains('flipping')) return;

            const slotIndex = card.dataset.slotIndex;
            
            // å¦‚æœæ˜¯è¬ä½ (index 0)ï¼Œè§¸ç™¼ç‰¹æ•ˆ
            if (slotIndex === "0") {
                revealSpecialCard(card);
            } else {
                // å…¶ä»–ä½æ•¸æ­£å¸¸ç¿»
                revealOneCard(card);
            }
        }

        // --- è¬ä½ç‰¹æ•ˆé‚è¼¯ ---
        function revealSpecialCard(card) {
            // æ¨™è¨˜ç‹€æ…‹
            card.classList.remove('locked');
            card.classList.add('done');
            card.classList.add('flipping'); // é˜²æ­¢é‡è¤‡é»æ“Š

            // 1. å£“æš—èƒŒæ™¯
            const dimmer = document.getElementById('dim-overlay');
            dimmer.style.display = 'block';
            setTimeout(() => dimmer.style.opacity = '1', 10);

            // 2. æ”¾å¤§ & æº–å‚™
            card.classList.add('special-prepare');

            // 3. 0.5ç§’å¾Œé–‹å§‹éœ‡å‹•
            setTimeout(() => {
                card.classList.add('special-shake');
            }, 500);

            // 4. éœ‡å‹• 1.5 ç§’å¾Œç¿»é–‹
            setTimeout(() => {
                card.classList.remove('special-shake');
                card.classList.remove('special-prepare'); // ç§»é™¤æ”¾å¤§æº–å‚™ï¼Œæ”¹ç”¨ revealed æ¨£å¼
                
                // åŸ·è¡Œç¿»è½‰å‹•ç•«
                card.style.animation = 'flipEffect 0.6s forwards';

                setTimeout(() => {
                    card.classList.add('revealed');
                    card.classList.add('special-revealed'); // åŠ å…¥é‡‘è‰²æ¨£å¼
                    const isRed = (card.dataset.suit === 'â™¥' || card.dataset.suit === 'â™¦');
                    card.classList.add(isRed ? 'red' : 'black');
                    
                    card.innerHTML = `
                        <div class="suit-small">${card.dataset.suit}</div>
                        <div class="val-large">${card.dataset.rank}</div>
                    `;

                    // æ¢å¾©èƒŒæ™¯
                    dimmer.style.opacity = '0';
                    setTimeout(() => dimmer.style.display = 'none', 500);

                    // çµç®—
                    finishOneCardReveal();

                }, 300); // ç¿»è½‰åˆ°ä¸€åŠæ™‚æ›å…§å®¹

            }, 2000); // ç¸½ç­‰å¾…æ™‚é–“
        }

        function revealOneCard(card) {
            card.classList.remove('locked');
            card.classList.add('done');
            card.classList.add('flipping'); 

            setTimeout(() => {
                card.classList.add('revealed');
                const isRed = (card.dataset.suit === 'â™¥' || card.dataset.suit === 'â™¦');
                card.classList.add(isRed ? 'red' : 'black');
                
                card.innerHTML = `
                    <div class="suit-small">${card.dataset.suit}</div>
                    <div class="val-large">${card.dataset.rank}</div>
                `;
                
                finishOneCardReveal();

            }, 300);
        }

        function finishOneCardReveal() {
            revealedCount++;
            if (revealedCount === 5) {
                setTimeout(calculateAndShowResult, 1000);
            }
        }

        function calculateAndShowResult() {
            let totalAmountStr = "";
            slotState.forEach(card => {
                totalAmountStr += card.dataset.value;
            });
            
            const finalAmount = parseInt(totalAmountStr);

            document.getElementById('result-overlay').style.display = 'flex';
            const scoreEl = document.getElementById('final-score');
            
            let current = 0;
            const step = Math.max(1, Math.floor(finalAmount / 30));
            const timer = setInterval(() => {
                current += step;
                if (current >= finalAmount) {
                    current = finalAmount;
                    clearInterval(timer);
                }
                scoreEl.innerText = `$${current.toLocaleString()}`;
            }, 30);
        }

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);

    </script>
</body>
</html>
